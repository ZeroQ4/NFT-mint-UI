{"ast":null,"code":"import * as anchor from '@project-serum/anchor';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { SystemProgram, SYSVAR_SLOT_HASHES_PUBKEY } from '@solana/web3.js';\nimport { sendTransactions, SequenceType } from './connection';\nimport { CIVIC, getAtaForMint, getNetworkExpire, getNetworkToken, SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID } from './utils';\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey('cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ');\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\nexport const awaitTransactionSignatureConfirmation = async (txid, timeout, connection, queryStatus = false) => {\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (associatedTokenAddress, payer, walletAddress, splTokenMintAddress) => {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n};\n\nexport const getCandyMachineState = async (anchorWallet, candyMachineId, connection) => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed'\n  });\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n  const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n  const state = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      authority: state.authority,\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive: false,\n      isPresale: false,\n      isWhitelistOnly: false,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n      retainAuthority: state.data.retainAuthority\n    }\n  };\n};\n\nconst getMasterEdition = async (mint) => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('edition')], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nconst getMetadata = async (mint) => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nexport const getCandyMachineCreator = async (candyMachine) => {\n  return await anchor.web3.PublicKey.findProgramAddress([Buffer.from('candy_machine'), candyMachine.toBuffer()], CANDY_MACHINE_PROGRAM);\n};\nexport const getCollectionPDA = async (candyMachineAddress) => {\n  return await anchor.web3.PublicKey.findProgramAddress([Buffer.from('collection'), candyMachineAddress.toBuffer()], CANDY_MACHINE_PROGRAM);\n};\nexport const getCollectionAuthorityRecordPDA = async (mint, newAuthority) => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('collection_authority'), newAuthority.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\nexport const createAccountsForMint = async (candyMachine, payer) => {\n  const mint = anchor.web3.Keypair.generate();\n  const userTokenAccountAddress = (await getAtaForMint(mint.publicKey, payer))[0];\n  const signers = [mint];\n  const instructions = [anchor.web3.SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: mint.publicKey,\n    space: MintLayout.span,\n    lamports: await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    programId: TOKEN_PROGRAM_ID\n  }), Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer), createAssociatedTokenAccountInstruction(userTokenAccountAddress, payer, payer, mint.publicKey), Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, userTokenAccountAddress, payer, [], 1)];\n  return {\n    mint: mint,\n    userTokenAccount: userTokenAccountAddress,\n    transaction: (await sendTransactions(candyMachine.program.provider.connection, candyMachine.program.provider.wallet, [instructions], [signers], SequenceType.StopOnFailure, 'singleGossip', () => {}, () => false, undefined, [], [])).txs[0].txid\n  };\n};\nexport const mintOneToken = async (candyMachine, payer, mint, beforeTransactions = [], afterTransactions = [], setupState) => {\n  const userTokenAccountAddress = (await getAtaForMint(mint.publicKey, payer))[0];\n  const userPayingAccountAddress = candyMachine.state.tokenMint ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0] : payer;\n  const candyMachineAddress = candyMachine.id;\n  const remainingAccounts = [];\n  const instructions = [];\n  const signers = [];\n  console.log('SetupState: ', setupState);\n\n  if (!setupState) {\n    signers.push(mint);\n    instructions.push(...[anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports: await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),\n      programId: TOKEN_PROGRAM_ID\n    }), Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer), createAssociatedTokenAccountInstruction(userTokenAccountAddress, payer, payer, mint.publicKey), Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, userTokenAccountAddress, payer, [], 1)]);\n  }\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (await getNetworkToken(payer, candyMachine.state.gatekeeper.gatekeeperNetwork))[0],\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: (await getNetworkExpire(candyMachine.state.gatekeeper.gatekeeperNetwork))[0],\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(candyMachine.state.whitelistMintSettings.mint);\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: payer,\n        isWritable: false,\n        isSigner: true\n      });\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false\n    });\n    remainingAccounts.push({\n      pubkey: payer,\n      isWritable: false,\n      isSigner: true\n    });\n  }\n\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(candyMachineAddress);\n  console.log(remainingAccounts.map(rm => rm.pubkey.toBase58()));\n  instructions.push(await candyMachine.program.instruction.mintNft(creatorBump, {\n    accounts: {\n      candyMachine: candyMachineAddress,\n      candyMachineCreator,\n      payer: payer,\n      wallet: candyMachine.state.treasury,\n      mint: mint.publicKey,\n      metadata: metadataAddress,\n      masterEdition,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n      instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY\n    },\n    remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined\n  }));\n  const [collectionPDA] = await getCollectionPDA(candyMachineAddress);\n  const collectionPDAAccount = await candyMachine.program.provider.connection.getAccountInfo(collectionPDA);\n\n  if (collectionPDAAccount && candyMachine.state.retainAuthority) {\n    try {\n      const collectionData = await candyMachine.program.account.collectionPda.fetch(collectionPDA);\n      console.log(collectionData);\n      const collectionMint = collectionData.mint;\n      const collectionAuthorityRecord = await getCollectionAuthorityRecordPDA(collectionMint, collectionPDA);\n      console.log(collectionMint);\n\n      if (collectionMint) {\n        const collectionMetadata = await getMetadata(collectionMint);\n        const collectionMasterEdition = await getMasterEdition(collectionMint);\n        console.log('Collection PDA: ', collectionPDA.toBase58());\n        console.log('Authority: ', candyMachine.state.authority.toBase58());\n        instructions.push(await candyMachine.program.instruction.setCollectionDuringMint({\n          accounts: {\n            candyMachine: candyMachineAddress,\n            metadata: metadataAddress,\n            payer: payer,\n            collectionPda: collectionPDA,\n            tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n            instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n            collectionMint,\n            collectionMetadata,\n            collectionMasterEdition,\n            authority: candyMachine.state.authority,\n            collectionAuthorityRecord\n          }\n        }));\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const instructionsMatrix = [instructions];\n  const signersMatrix = [signers];\n\n  try {\n    const txns = (await sendTransactions(candyMachine.program.provider.connection, candyMachine.program.provider.wallet, instructionsMatrix, signersMatrix, SequenceType.StopOnFailure, 'singleGossip', () => {}, () => false, undefined, beforeTransactions, afterTransactions)).txs.map(t => t.txid);\n    const mintTxn = txns[0];\n    return {\n      mintTxId: mintTxn,\n      metadataKey: metadataAddress\n    };\n  } catch (e) {\n    console.log(e);\n  }\n\n  return null;\n};\nexport const shortenAddress = (address, chars = 4) => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};","map":{"version":3,"sources":["D:/GitHub/NFT-mint-UI/src/candy-machine.ts"],"names":["anchor","MintLayout","TOKEN_PROGRAM_ID","Token","SystemProgram","SYSVAR_SLOT_HASHES_PUBKEY","sendTransactions","SequenceType","CIVIC","getAtaForMint","getNetworkExpire","getNetworkToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","CANDY_MACHINE_PROGRAM","web3","PublicKey","TOKEN_METADATA_PROGRAM_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","signatureStatuses","getSignatureStatuses","value","e","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","data","Buffer","from","getCandyMachineState","anchorWallet","candyMachineId","provider","Provider","preflightCommitment","idl","Program","fetchIdl","program","state","account","candyMachine","fetch","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","id","authority","isSoldOut","isActive","isPresale","isWhitelistOnly","goLiveDate","treasury","wallet","tokenMint","gatekeeper","endSettings","whitelistMintSettings","hiddenSettings","price","retainAuthority","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getCandyMachineCreator","getCollectionPDA","candyMachineAddress","getCollectionAuthorityRecordPDA","newAuthority","createAccountsForMint","Keypair","generate","userTokenAccountAddress","publicKey","signers","instructions","createAccount","fromPubkey","newAccountPubkey","space","span","lamports","getMinimumBalanceForRentExemption","createInitMintInstruction","createMintToInstruction","userTokenAccount","transaction","StopOnFailure","undefined","txs","mintOneToken","beforeTransactions","afterTransactions","setupState","userPayingAccountAddress","remainingAccounts","push","gatekeeperNetwork","expireOnUse","whitelistToken","mode","burnEveryTime","metadataAddress","masterEdition","candyMachineCreator","creatorBump","map","rm","toBase58","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","collectionPDA","collectionPDAAccount","getAccountInfo","collectionData","collectionPda","collectionMint","collectionAuthorityRecord","collectionMetadata","collectionMasterEdition","setCollectionDuringMint","error","instructionsMatrix","signersMatrix","txns","t","mintTxn","mintTxId","metadataKey","shortenAddress","address","chars","slice","ms"],"mappings":"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","sourcesContent":["import * as anchor from '@project-serum/anchor';\r\n\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\r\nimport {\r\n    SystemProgram,\r\n    Transaction,\r\n    SYSVAR_SLOT_HASHES_PUBKEY,\r\n} from '@solana/web3.js';\r\nimport { sendTransactions, SequenceType } from './connection';\r\n\r\nimport {\r\n    CIVIC,\r\n    getAtaForMint,\r\n    getNetworkExpire,\r\n    getNetworkToken,\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n} from './utils';\r\n\r\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\r\n    'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ',\r\n);\r\n\r\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n    'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\r\n);\r\n\r\ninterface CandyMachineState {\r\n    authority: anchor.web3.PublicKey;\r\n    itemsAvailable: number;\r\n    itemsRedeemed: number;\r\n    itemsRemaining: number;\r\n    treasury: anchor.web3.PublicKey;\r\n    tokenMint: null | anchor.web3.PublicKey;\r\n    isSoldOut: boolean;\r\n    isActive: boolean;\r\n    isPresale: boolean;\r\n    isWhitelistOnly: boolean;\r\n    goLiveDate: anchor.BN;\r\n    price: anchor.BN;\r\n    gatekeeper: null | {\r\n        expireOnUse: boolean;\r\n        gatekeeperNetwork: anchor.web3.PublicKey;\r\n    };\r\n    endSettings: null | {\r\n        number: anchor.BN;\r\n        endSettingType: any;\r\n    };\r\n    whitelistMintSettings: null | {\r\n        mode: any;\r\n        mint: anchor.web3.PublicKey;\r\n        presale: boolean;\r\n        discountPrice: null | anchor.BN;\r\n    };\r\n    hiddenSettings: null | {\r\n        name: string;\r\n        uri: string;\r\n        hash: Uint8Array;\r\n    };\r\n    retainAuthority: boolean;\r\n}\r\n\r\nexport interface CandyMachineAccount {\r\n    id: anchor.web3.PublicKey;\r\n    program: anchor.Program;\r\n    state: CandyMachineState;\r\n}\r\n\r\nexport const awaitTransactionSignatureConfirmation = async (\r\n    txid: anchor.web3.TransactionSignature,\r\n    timeout: number,\r\n    connection: anchor.web3.Connection,\r\n    queryStatus = false,\r\n): Promise<anchor.web3.SignatureStatus | null | void> => {\r\n    let done = false;\r\n    let status: anchor.web3.SignatureStatus | null | void = {\r\n        slot: 0,\r\n        confirmations: 0,\r\n        err: null,\r\n    };\r\n    let subId = 0;\r\n    status = await new Promise(async (resolve, reject) => {\r\n        setTimeout(() => {\r\n            if (done) {\r\n                return;\r\n            }\r\n            done = true;\r\n            console.log('Rejecting for timeout...');\r\n            reject({ timeout: true });\r\n        }, timeout);\r\n\r\n        while (!done && queryStatus) {\r\n            // eslint-disable-next-line no-loop-func\r\n            (async () => {\r\n                try {\r\n                    const signatureStatuses = await connection.getSignatureStatuses([\r\n                        txid,\r\n                    ]);\r\n                    status = signatureStatuses && signatureStatuses.value[0];\r\n                    if (!done) {\r\n                        if (!status) {\r\n                            console.log('REST null result for', txid, status);\r\n                        } else if (status.err) {\r\n                            console.log('REST error for', txid, status);\r\n                            done = true;\r\n                            reject(status.err);\r\n                        } else if (!status.confirmations) {\r\n                            console.log('REST no confirmations for', txid, status);\r\n                        } else {\r\n                            console.log('REST confirmation for', txid, status);\r\n                            done = true;\r\n                            resolve(status);\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!done) {\r\n                        console.log('REST connection error: txid', txid, e);\r\n                    }\r\n                }\r\n            })();\r\n            await sleep(2000);\r\n        }\r\n    });\r\n\r\n    //@ts-ignore\r\n    if (connection._signatureSubscriptions[subId]) {\r\n        connection.removeSignatureListener(subId);\r\n    }\r\n    done = true;\r\n    console.log('Returning status', status);\r\n    return status;\r\n};\r\n\r\nconst createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress: anchor.web3.PublicKey,\r\n    payer: anchor.web3.PublicKey,\r\n    walletAddress: anchor.web3.PublicKey,\r\n    splTokenMintAddress: anchor.web3.PublicKey,\r\n) => {\r\n    const keys = [\r\n        { pubkey: payer, isSigner: true, isWritable: true },\r\n        { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n        { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n        { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n        {\r\n            pubkey: anchor.web3.SystemProgram.programId,\r\n            isSigner: false,\r\n            isWritable: false,\r\n        },\r\n        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n        {\r\n            pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n            isSigner: false,\r\n            isWritable: false,\r\n        },\r\n    ];\r\n    return new anchor.web3.TransactionInstruction({\r\n        keys,\r\n        programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n        data: Buffer.from([]),\r\n    });\r\n};\r\n\r\nexport const getCandyMachineState = async (\r\n    anchorWallet: anchor.Wallet,\r\n    candyMachineId: anchor.web3.PublicKey,\r\n    connection: anchor.web3.Connection,\r\n): Promise<CandyMachineAccount> => {\r\n    const provider = new anchor.Provider(connection, anchorWallet, {\r\n        preflightCommitment: 'processed',\r\n    });\r\n\r\n    const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\r\n\r\n    const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, provider);\r\n\r\n    const state: any = await program.account.candyMachine.fetch(candyMachineId);\r\n    const itemsAvailable = state.data.itemsAvailable.toNumber();\r\n    const itemsRedeemed = state.itemsRedeemed.toNumber();\r\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n\r\n    return {\r\n        id: candyMachineId,\r\n        program,\r\n        state: {\r\n            authority: state.authority,\r\n            itemsAvailable,\r\n            itemsRedeemed,\r\n            itemsRemaining,\r\n            isSoldOut: itemsRemaining === 0,\r\n            isActive: false,\r\n            isPresale: false,\r\n            isWhitelistOnly: false,\r\n            goLiveDate: state.data.goLiveDate,\r\n            treasury: state.wallet,\r\n            tokenMint: state.tokenMint,\r\n            gatekeeper: state.data.gatekeeper,\r\n            endSettings: state.data.endSettings,\r\n            whitelistMintSettings: state.data.whitelistMintSettings,\r\n            hiddenSettings: state.data.hiddenSettings,\r\n            price: state.data.price,\r\n            retainAuthority: state.data.retainAuthority,\r\n        },\r\n    };\r\n};\r\n\r\nconst getMasterEdition = async (\r\n    mint: anchor.web3.PublicKey,\r\n): Promise<anchor.web3.PublicKey> => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [\r\n                Buffer.from('metadata'),\r\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                mint.toBuffer(),\r\n                Buffer.from('edition'),\r\n            ],\r\n            TOKEN_METADATA_PROGRAM_ID,\r\n        )\r\n    )[0];\r\n};\r\n\r\nconst getMetadata = async (\r\n    mint: anchor.web3.PublicKey,\r\n): Promise<anchor.web3.PublicKey> => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [\r\n                Buffer.from('metadata'),\r\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                mint.toBuffer(),\r\n            ],\r\n            TOKEN_METADATA_PROGRAM_ID,\r\n        )\r\n    )[0];\r\n};\r\n\r\nexport const getCandyMachineCreator = async (\r\n    candyMachine: anchor.web3.PublicKey,\r\n): Promise<[anchor.web3.PublicKey, number]> => {\r\n    return await anchor.web3.PublicKey.findProgramAddress(\r\n        [Buffer.from('candy_machine'), candyMachine.toBuffer()],\r\n        CANDY_MACHINE_PROGRAM,\r\n    );\r\n};\r\n\r\nexport const getCollectionPDA = async (\r\n    candyMachineAddress: anchor.web3.PublicKey,\r\n): Promise<[anchor.web3.PublicKey, number]> => {\r\n    return await anchor.web3.PublicKey.findProgramAddress(\r\n        [Buffer.from('collection'), candyMachineAddress.toBuffer()],\r\n        CANDY_MACHINE_PROGRAM,\r\n    );\r\n};\r\n\r\nexport interface CollectionData {\r\n    mint: anchor.web3.PublicKey;\r\n    candyMachine: anchor.web3.PublicKey;\r\n}\r\n\r\nexport const getCollectionAuthorityRecordPDA = async (\r\n    mint: anchor.web3.PublicKey,\r\n    newAuthority: anchor.web3.PublicKey,\r\n): Promise<anchor.web3.PublicKey> => {\r\n    return (\r\n        await anchor.web3.PublicKey.findProgramAddress(\r\n            [\r\n                Buffer.from('metadata'),\r\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n                mint.toBuffer(),\r\n                Buffer.from('collection_authority'),\r\n                newAuthority.toBuffer(),\r\n            ],\r\n            TOKEN_METADATA_PROGRAM_ID,\r\n        )\r\n    )[0];\r\n};\r\n\r\nexport type SetupState = {\r\n    mint: anchor.web3.Keypair;\r\n    userTokenAccount: anchor.web3.PublicKey;\r\n    transaction: string;\r\n};\r\n\r\nexport const createAccountsForMint = async (\r\n    candyMachine: CandyMachineAccount,\r\n    payer: anchor.web3.PublicKey,\r\n): Promise<SetupState> => {\r\n    const mint = anchor.web3.Keypair.generate();\r\n    const userTokenAccountAddress = (\r\n        await getAtaForMint(mint.publicKey, payer)\r\n    )[0];\r\n\r\n    const signers: anchor.web3.Keypair[] = [mint];\r\n    const instructions = [\r\n        anchor.web3.SystemProgram.createAccount({\r\n            fromPubkey: payer,\r\n            newAccountPubkey: mint.publicKey,\r\n            space: MintLayout.span,\r\n            lamports:\r\n                await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\r\n                    MintLayout.span,\r\n                ),\r\n            programId: TOKEN_PROGRAM_ID,\r\n        }),\r\n        Token.createInitMintInstruction(\r\n            TOKEN_PROGRAM_ID,\r\n            mint.publicKey,\r\n            0,\r\n            payer,\r\n            payer,\r\n        ),\r\n        createAssociatedTokenAccountInstruction(\r\n            userTokenAccountAddress,\r\n            payer,\r\n            payer,\r\n            mint.publicKey,\r\n        ),\r\n        Token.createMintToInstruction(\r\n            TOKEN_PROGRAM_ID,\r\n            mint.publicKey,\r\n            userTokenAccountAddress,\r\n            payer,\r\n            [],\r\n            1,\r\n        ),\r\n    ];\r\n\r\n    return {\r\n        mint: mint,\r\n        userTokenAccount: userTokenAccountAddress,\r\n        transaction: (\r\n            await sendTransactions(\r\n                candyMachine.program.provider.connection,\r\n                candyMachine.program.provider.wallet,\r\n                [instructions],\r\n                [signers],\r\n                SequenceType.StopOnFailure,\r\n                'singleGossip',\r\n                () => {},\r\n                () => false,\r\n                undefined,\r\n                [],\r\n                [],\r\n            )\r\n        ).txs[0].txid,\r\n    };\r\n};\r\n\r\ntype MintResult = {\r\n    mintTxId: string;\r\n    metadataKey: anchor.web3.PublicKey;\r\n};\r\n\r\nexport const mintOneToken = async (\r\n    candyMachine: CandyMachineAccount,\r\n    payer: anchor.web3.PublicKey,\r\n    mint: anchor.web3.Keypair,\r\n    beforeTransactions: Transaction[] = [],\r\n    afterTransactions: Transaction[] = [],\r\n    setupState?: SetupState,\r\n): Promise<MintResult | null> => {\r\n    const userTokenAccountAddress = (\r\n        await getAtaForMint(mint.publicKey, payer)\r\n    )[0];\r\n\r\n    const userPayingAccountAddress = candyMachine.state.tokenMint\r\n        ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\r\n        : payer;\r\n\r\n    const candyMachineAddress = candyMachine.id;\r\n    const remainingAccounts = [];\r\n    const instructions = [];\r\n    const signers: anchor.web3.Keypair[] = [];\r\n    console.log('SetupState: ', setupState);\r\n    if (!setupState) {\r\n        signers.push(mint);\r\n        instructions.push(\r\n            ...[\r\n                anchor.web3.SystemProgram.createAccount({\r\n                    fromPubkey: payer,\r\n                    newAccountPubkey: mint.publicKey,\r\n                    space: MintLayout.span,\r\n                    lamports:\r\n                        await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\r\n                            MintLayout.span,\r\n                        ),\r\n                    programId: TOKEN_PROGRAM_ID,\r\n                }),\r\n                Token.createInitMintInstruction(\r\n                    TOKEN_PROGRAM_ID,\r\n                    mint.publicKey,\r\n                    0,\r\n                    payer,\r\n                    payer,\r\n                ),\r\n                createAssociatedTokenAccountInstruction(\r\n                    userTokenAccountAddress,\r\n                    payer,\r\n                    payer,\r\n                    mint.publicKey,\r\n                ),\r\n                Token.createMintToInstruction(\r\n                    TOKEN_PROGRAM_ID,\r\n                    mint.publicKey,\r\n                    userTokenAccountAddress,\r\n                    payer,\r\n                    [],\r\n                    1,\r\n                ),\r\n            ],\r\n        );\r\n    }\r\n\r\n    if (candyMachine.state.gatekeeper) {\r\n        remainingAccounts.push({\r\n            pubkey: (\r\n                await getNetworkToken(\r\n                    payer,\r\n                    candyMachine.state.gatekeeper.gatekeeperNetwork,\r\n                )\r\n            )[0],\r\n            isWritable: true,\r\n            isSigner: false,\r\n        });\r\n\r\n        if (candyMachine.state.gatekeeper.expireOnUse) {\r\n            remainingAccounts.push({\r\n                pubkey: CIVIC,\r\n                isWritable: false,\r\n                isSigner: false,\r\n            });\r\n            remainingAccounts.push({\r\n                pubkey: (\r\n                    await getNetworkExpire(\r\n                        candyMachine.state.gatekeeper.gatekeeperNetwork,\r\n                    )\r\n                )[0],\r\n                isWritable: false,\r\n                isSigner: false,\r\n            });\r\n        }\r\n    }\r\n    if (candyMachine.state.whitelistMintSettings) {\r\n        const mint = new anchor.web3.PublicKey(\r\n            candyMachine.state.whitelistMintSettings.mint,\r\n        );\r\n\r\n        const whitelistToken = (await getAtaForMint(mint, payer))[0];\r\n        remainingAccounts.push({\r\n            pubkey: whitelistToken,\r\n            isWritable: true,\r\n            isSigner: false,\r\n        });\r\n\r\n        if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\r\n            remainingAccounts.push({\r\n                pubkey: mint,\r\n                isWritable: true,\r\n                isSigner: false,\r\n            });\r\n            remainingAccounts.push({\r\n                pubkey: payer,\r\n                isWritable: false,\r\n                isSigner: true,\r\n            });\r\n        }\r\n    }\r\n\r\n    if (candyMachine.state.tokenMint) {\r\n        remainingAccounts.push({\r\n            pubkey: userPayingAccountAddress,\r\n            isWritable: true,\r\n            isSigner: false,\r\n        });\r\n        remainingAccounts.push({\r\n            pubkey: payer,\r\n            isWritable: false,\r\n            isSigner: true,\r\n        });\r\n    }\r\n    const metadataAddress = await getMetadata(mint.publicKey);\r\n    const masterEdition = await getMasterEdition(mint.publicKey);\r\n\r\n    const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\r\n        candyMachineAddress,\r\n    );\r\n\r\n    console.log(remainingAccounts.map(rm => rm.pubkey.toBase58()));\r\n    instructions.push(\r\n        await candyMachine.program.instruction.mintNft(creatorBump, {\r\n            accounts: {\r\n                candyMachine: candyMachineAddress,\r\n                candyMachineCreator,\r\n                payer: payer,\r\n                wallet: candyMachine.state.treasury,\r\n                mint: mint.publicKey,\r\n                metadata: metadataAddress,\r\n                masterEdition,\r\n                mintAuthority: payer,\r\n                updateAuthority: payer,\r\n                tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n                tokenProgram: TOKEN_PROGRAM_ID,\r\n                systemProgram: SystemProgram.programId,\r\n                rent: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\r\n                recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\r\n                instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\r\n            },\r\n            remainingAccounts:\r\n                remainingAccounts.length > 0 ? remainingAccounts : undefined,\r\n        }),\r\n    );\r\n\r\n    const [collectionPDA] = await getCollectionPDA(candyMachineAddress);\r\n    const collectionPDAAccount =\r\n        await candyMachine.program.provider.connection.getAccountInfo(\r\n            collectionPDA,\r\n        );\r\n\r\n    if (collectionPDAAccount && candyMachine.state.retainAuthority) {\r\n        try {\r\n            const collectionData =\r\n                (await candyMachine.program.account.collectionPda.fetch(\r\n                    collectionPDA,\r\n                )) as CollectionData;\r\n            console.log(collectionData);\r\n            const collectionMint = collectionData.mint;\r\n            const collectionAuthorityRecord = await getCollectionAuthorityRecordPDA(\r\n                collectionMint,\r\n                collectionPDA,\r\n            );\r\n            console.log(collectionMint);\r\n            if (collectionMint) {\r\n                const collectionMetadata = await getMetadata(collectionMint);\r\n                const collectionMasterEdition = await getMasterEdition(collectionMint);\r\n                console.log('Collection PDA: ', collectionPDA.toBase58());\r\n                console.log('Authority: ', candyMachine.state.authority.toBase58());\r\n                instructions.push(\r\n                    await candyMachine.program.instruction.setCollectionDuringMint({\r\n                        accounts: {\r\n                            candyMachine: candyMachineAddress,\r\n                            metadata: metadataAddress,\r\n                            payer: payer,\r\n                            collectionPda: collectionPDA,\r\n                            tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n                            instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\r\n                            collectionMint,\r\n                            collectionMetadata,\r\n                            collectionMasterEdition,\r\n                            authority: candyMachine.state.authority,\r\n                            collectionAuthorityRecord,\r\n                        },\r\n                    }),\r\n                );\r\n            }\r\n        } catch (error) {\r\n            console.error(error);\r\n        }\r\n    }\r\n\r\n    const instructionsMatrix = [instructions];\r\n    const signersMatrix = [signers];\r\n\r\n    try {\r\n        const txns = (\r\n            await sendTransactions(\r\n                candyMachine.program.provider.connection,\r\n                candyMachine.program.provider.wallet,\r\n                instructionsMatrix,\r\n                signersMatrix,\r\n                SequenceType.StopOnFailure,\r\n                'singleGossip',\r\n                () => {},\r\n                () => false,\r\n                undefined,\r\n                beforeTransactions,\r\n                afterTransactions,\r\n            )\r\n        ).txs.map(t => t.txid);\r\n        const mintTxn = txns[0];\r\n        return {\r\n            mintTxId: mintTxn,\r\n            metadataKey: metadataAddress,\r\n        };\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n    return null;\r\n};\r\n\r\nexport const shortenAddress = (address: string, chars = 4): string => {\r\n    return `${address.slice(0, chars)}...${address.slice(-chars)}`;\r\n};\r\n\r\nconst sleep = (ms: number): Promise<void> => {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}